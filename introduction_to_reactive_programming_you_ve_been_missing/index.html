<!DOCTYPE html><html lang="ru"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Недостающее введение в Реактивное Программирование | Разработка всего</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=0.0.0"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans|PT+Sans+Narrow:400,700|PT+Sans+Caption"><link href='' rel='stylesheet' type='text/css'></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Недостающее введение в Реактивное Программирование</h1><a id="logo" href="/.">Разработка всего</a><p class="description"></p></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Недостающее введение в Реактивное Программирование</h1><div class="post-content"><p>Просто изучение чего-то нового – это трудно, но может быть ещё труднее из-за отсутствия хорошего материала. Когда я начал, я пытался искать руководства, но нашёл только горсть практических пошаговых инструкций, которые были очень поверхностны и никогда не решали проблему построения архитектуры полностью. Документация библиотек часто не помогает, когда ты пытаешься понять смысл некоторых функций. Я имею ввиду, взгляните на это:</p>
<blockquote>
<p><strong>Rx.Observable.prototype.flatMapLatest(selector, [thisArg])</strong><br>Проецирует каждый элемент наблюдаемой последовательности на новую последовательность наблюдаемых последовательностей с включением индекса элемента и последующей трансформации наблюдаемой последовательности наблюдаемых последовательностей в наблюдаемую последовательность передающую значения только из последних наблюдаемых последовательностей.</p>
</blockquote>
<p>О мой бог.<br>Я прочёл две книги – одна давала общую картину, в то время как другая погружалась в низкоуровневое использование реактивной библиотеки. В конечном итоге я выбрал тяжёлый путь для изучения Реактивного Программирования: выяснить как это работает по ходу дела при разработке приложения. На моей работе в Futurice я использовал эту технологию в реальном проекте и постоянно получал поддержку коллег когда попадал в неприятности.<br>Наисложнейшая часть изучения – это <strong>мышление в Реактивной среде</strong>. Нужно отпустить старые императивные и привычки хранения состояния типичного программирования, и принудить мозг работать в другой парадигме. Я не нашёл никаких пошаговых руководств в интернете об этом аспекте, и я думаю, что мир заслуживает практического руководства о том, как начать думать в Реактивности. Итак, теперь мы знаем с чего можно начать, после чего документация библиотек наконец станет полезной и будет помогать нам в дальнейшем изучении.</p>
<h2 id="Что-же-такое-Реактивное-Программирование"><a href="#Что-же-такое-Реактивное-Программирование" class="headerlink" title="Что же такое Реактивное Программирование?"></a>Что же такое Реактивное Программирование?</h2><p>Есть много плохих объяснений и определений. Википедия очень общая и теоретическая как обычно. Канонические ответы на StackOverflow очевидно непригодны для начинающих. <a href="http://www.reactivemanifesto.org/" target="_blank" rel="external">Манифест Реактивности</a> звучит как что-то, что нужно показать менеджеру проекта или человеку принимающему решения в вашей компании. Терминология Майкрософта “Rx = Observables + LINQ + Schedulers” достаточно тяжела и после разбирательств с ней многие из нас остаются в замешательстве. Термины “Реактивный” и “Распространение изменений” [Propagation of change] не выражают ничего особенно отличающегося от того, с чем типичная MV* архитектура или какие-либо языки уже справляются. Конечно представления моего фреймворка реагируют на изменения моделей. Конечно изменения распространяются. Если бы этого не происходило, ничего бы попросту не работало.<br>Чтожь начнём отсеивать всякую ерунду.</p>
<h3 id="Реактивное-программирование-–-это-программирование-с-асинхронными-потоками-данных"><a href="#Реактивное-программирование-–-это-программирование-с-асинхронными-потоками-данных" class="headerlink" title="Реактивное программирование – это программирование с асинхронными потоками данных"></a>Реактивное программирование – это программирование с асинхронными потоками данных</h3><p>В некотором отношении в этом нет ничего особенного. Шина событий или типичное событие клика в действительности – это поток событий, который вы можете программно наблюдать и реализовывать необходимую логику. Реактивность – это та же самая идея на стероидах. Вы можете создать поток данных из чего угодно, не только из событий клика или наведения мыши. Потоки дешёвые с точки зрения ресурсов и повсеместные, всё что угодно может быть потоком: переменная, пользовательский ввод, свойства, кеш данных, структуры данных… Для примера представьте, что ваша Twitter лента могла бы быть потоком данных в том же смысле как и клик мышью. Вы можете слушать этот поток и реагировать соответствующим образом.</p>
<h3 id="Более-того-вы-получаете-изумительный-набор-функций-для-комбинирования-создания-и-фильтрации-любого-из-этих-потоков"><a href="#Более-того-вы-получаете-изумительный-набор-функций-для-комбинирования-создания-и-фильтрации-любого-из-этих-потоков" class="headerlink" title="Более того, вы получаете изумительный набор функций для комбинирования, создания и фильтрации любого из этих потоков"></a>Более того, вы получаете изумительный набор функций для комбинирования, создания и фильтрации любого из этих потоков</h3><p>Это и есть место в которое ударяет “функциональная” магия - поток может быть использован как входная точка в другой поток. Даже несколько потоков могут быть использованы как входная точка для другого потока. Вы можете сделать слияние двух потоков. Вы можете фильтровать потоки чтобы дать другому потоку только те значения в которых вы заинтересованы. Вы можете проецировать [map] значения из одного потока в другой.<br>Потоки достаточно центральная сущность в Реактивности, и давайте посмотрим на них внимательнее, начиная с хорошо всем знакомого события “клик на кнопке”.<br><img src="/introduction_to_reactive_programming_you_ve_been_missing/click_event_stream.png" alt="Поток события клика"><br>Поток – <strong>это последовательность происходящих событий упорядоченных во времени</strong>. Он может передавать три различные вещи: значение (какого-либо типа), ошибку, состояние завершения. Состояние завершения происходит, например, когда текущее окно или представление содержащее нашу кнопку закрывается.<br>Мы ловим переданные события только <strong>асинхронно</strong>, с помощью определения функций: одна, которая будет выполнена когда значение будет получено, другая когда возникнет ошибка, и ещё одна функция, когда поток будет завершён. Иногда последние два случая могут быть опущены и вы можете сосредоточиться на функции для значений. “Прослушивание” событий называется <strong>подпиской</strong> [<strong>subscribing</strong>]. Функции, которые мы определяем – наблюдатели [observers]. Поток – субъект наблюдения, или наблюдаемая сущность [observable]. Эта схема в точности реализует шаблон проектирования <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" target="_blank" rel="external">“Наблюдатель”</a>).<br>Альтернативный путь изображений диаграмм описывающих эти процессы – это ASCII, который мы будем использовать в некоторых местах руководства.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">--a---b-c---d---X---|-&gt;</div><div class="line"></div><div class="line">a, b, c, d произошедшие события</div><div class="line">X ошибка</div><div class="line">| сигнал завершения</div><div class="line">---&gt; Линия времени</div></pre></td></tr></table></figure></p>
<p>Теперь это выглядит более осязаемым, и я не хочу никого утомить, по-этому давайте сделаем что-нибудь новое: создадим новый поток событий клика трансформирующий изначальный поток событий клика.<br>Для начала давайте создадим поток-счётчик, который определяет сколько раз кнопка была нажата. В большинстве реактивных библиотек к каждому потоку прилагается много функций, такие как <code>map</code>, <code>filter</code>, <code>scan</code> и другие. Когда вы вызываете одну из этих функций, такую как <code>clickStream.map(f)</code>, она возвращает новый поток основанный на потоке клика. Это ни в коем случае не модифицирует изначальное событие клика. Эти функции иммутабельны и идеально сочестаются с реактивными потоками. Это позволяет нам сцеплять функции таким образом <code>clickStream.map(f).scan(g)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  clickStream: ---c----c--c----c------c--&gt;</div><div class="line">               vvvvv map(c становится 1) vvvv</div><div class="line">               ---1----1--1----1------1--&gt;</div><div class="line">               vvvvvvvvv scan(+) vvvvvvvvv</div><div class="line">counterStream: ---1----2--3----4------5--&gt;</div></pre></td></tr></table></figure>
<p>Функция  <code>map(f)</code> заменяет (в новом потоке) каждое переданное значение согласно функии <code>f</code>, которую вы реализуете. В нашем случае, мы проецируем каждый клик на число <code>1</code>. Функция <code>scan(g)</code> аггрегирует все предыдущие значения  в потоке, производя значение <code>x = g(accumulated, current)</code>, где <code>g</code> – просто функция сложения в нашем примере. Затем <code>counterStream</code> передаёт полное общее количество кликов при каждом произошедшем клике.<br>Чтобы показать реальную силу реактивности, представим что мы хотим поток двойных кликов. Чтобы сделать это ещё интереснее, представим, что мы хотим новый поток, чтобы рассматривать тройные клики как двойные, или в общем множественные клики (два или больше). Вздохнём поглубже и представим как мы бы это сделали в традиционной императивной манере с хранением состояния. Ставлю, что это будет звучать довольно неприятно и будет необходимо выделить несколько переменных, чтобы хранить состояние и немного поиграть с временными интервалами.<br>Чтож, в реактивном программировании это делается достаточно просто. По факту логика умещается в <a href="http://jsfiddle.net/staltz/4gGgs/27/" target="_blank" rel="external">4 строки кода</a>. Но давайте проигнорируем код сейчас. Размышления в диаграммах – лучший способ, чтобы понять и создавать потоки, независимо начинающий ли вы в этом деле или эксперт.<br><img src="/introduction_to_reactive_programming_you_ve_been_missing/multiple_clicks_stream.png" alt="Поток множественных кликов"><br>Серые прямоугольники – это функции трансформирующие один поток в другой. Сначала мы аккумулируем клики в список пока не пройдёт 250 миллисекунд “молчания событий” (это то, чем занимается <code>buffer(stream.throttle(250ms)</code>), это вкратце. Не беспокойтесь о понимании деталей на этом этапе, мы просто демонстрируем Реактивность сейчас). В результате получаем поток списков, к которому мы применияем <code>map()</code> чтобы спроецировать каждый список в число, которое равно длине списка. В итоге, мы игнорируем числа равные 1, используя функцию фильтра filter(x &gt;= 2). Это то, что мы хотели получить: 3 операции для получения задуманного потока. После этого мы можем подписаться [subscribe] на поток, чтобы реагировать как нам угодно.<br>Я надеюсь вы наслаждаетесь красотой этого подхода. Этот пример только вершина айсберга: вы можете применять подобные операции на различных типах потоков, для примера, на API ответов; кроме того нам доступно ещё много других функций.</p>
<h2 id="Почему-следует-рассмотреть-вопрос-о-принятии-Реактивного-Программирования-RP"><a href="#Почему-следует-рассмотреть-вопрос-о-принятии-Реактивного-Программирования-RP" class="headerlink" title="Почему следует рассмотреть вопрос о принятии Реактивного Программирования [RP]?"></a>Почему следует рассмотреть вопрос о принятии Реактивного Программирования [RP]?</h2><p>Реактивное Программирование увеличивает уровень абстракции кода, и значит вы можете сфокусироваться на взаимозависимости событий которые определяют бизнес-логику в большей мере, чем постоянно играть с огромным количеством деталей реализации. Возможность написания более лаконичного кода с RP возрастает.<br>Преимущества наиболее очевидны в современных высокоинтерактивных веб и мобильных приложениях с множеством событий графического интерфейса связанных с событиями изменения данных. 10 лет назад, взаимодействие с web-страницами сводилось в основном к отправке длинных форм на бэкенд и выполнению простого рендеринга на фронтенде. Развитие технологий привело нас к приложениям работающим в реальном времени: модификация единственного поля формы вызывает событие сохранения на бэкенде, “лайк” какого-то контента может быть показан в реальном времени другим подключённым пользователям, и так далее.<br>Приложения в наши дни изобилуют событиями всех типов в реальном времени что обеспечивает высокоинтерактивный пользовательский опыт. Нам нужны инструменты чтобы должным образом справляться с этим, и Реактивное Программирование – это ответ.</p>
<h2 id="Пример-мышления-в-RP"><a href="#Пример-мышления-в-RP" class="headerlink" title="Пример мышления в RP"></a>Пример мышления в RP</h2><p>Давайте приступим к реальным вещам - к реальному примеру с пошаговым руководством о том, как думать в RP. Без синтетических примеров, без наполовину описанных концептов. В конце этого руководства мы получим реально функционирующий код, на пути к этому мы будем понимать какая часть в нём что именно делает.<br>Я выбрал <strong>JavaScript</strong> и <strong><a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">RxJS</a></strong> инструментами для реализации по следующим причинам: JavaScript – наиболее распространённый язык, а Rx* библиотека доступна для многих языков и платформ (<a href="https://rx.codeplex.com/" target="_blank" rel="external">.NET</a>, <a href="https://github.com/Netflix/RxJava" target="_blank" rel="external">Java</a>, Scala, Clojure,  <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">JavaScript</a>, <a href="https://github.com/Reactive-Extensions/Rx.rb" target="_blank" rel="external">Ruby</a>, <a href="https://github.com/Reactive-Extensions/RxPy" target="_blank" rel="external">Python</a>, <a href="https://github.com/Reactive-Extensions/RxCpp" target="_blank" rel="external">C++</a>, <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">Objective-C/Cocoa</a>, Groovy и другие). Но независимо от того, какие инструменты вы используете, вы можете получить ощутимую пользу от следующего руководства.</p>
<h2 id="Реализация-блока-предложений-“На-кого-подписаться”"><a href="#Реализация-блока-предложений-“На-кого-подписаться”" class="headerlink" title="Реализация блока предложений “На кого подписаться”"></a>Реализация блока предложений “На кого подписаться”</h2><p>В Twitter есть элемент графического интерфейса, который предлагает другие аккаунты на которые вы можете подписаться:<br><img src="/introduction_to_reactive_programming_you_ve_been_missing/twitter_who_to_follow_suggestions_box.png" alt="Twitter блок предложений кого читать"><br>Мы собираемся сфокусироваться на имитации его ключевых возможностей:<br>При старте загружаем данные аккаунтов из API и показываем 3 предложения.<br>При клике на кнопку “Обновить”, загружаем 3 другие аккаунта во все три строки.<br>При клике на кнопке ‘x’ около аккаунта, очищаем только текущий аккаунт и отображаем на его месте другой.<br>Каждая строка отображает аватар аккаунта и ссылку на его страницу.<br>Мы можем пропустить другие особенности и кнопки, потому что они второстепенны. И вместо Twitter, который с недавних пор закрыл своё API для неаутентифицированных пользователей, давайте построим графичекий интерфейс для подписки  на пользователей GitHub используя <a href="https://developer.github.com/v3/users/#get-all-users" target="_blank" rel="external">Github API  для получения пользователей</a>.<br>Завершённый код для всего этого готов и находится здесь <a href="http://jsfiddle.net/staltz/8jFJH/48/" target="_blank" rel="external">http://jsfiddle.net/staltz/8jFJH/48/</a> на тот случай если вы захотите бросить взгляд.</p>
<h2 id="Запрос-и-ответ"><a href="#Запрос-и-ответ" class="headerlink" title="Запрос и ответ"></a>Запрос и ответ</h2><p><strong>Как вы подойдёте к этой проблеме с Rx?</strong> Чтожь, чтобы начать, (почти) <em>всё может быть потоком</em>. Это мантра Rx. Давайте начнём с наипростейшего функционала: “При старте загружаем данные аккаунтов из API и показываем 3 предложения”. Здесь ничего особенного, (1) делаем запрос, (2) получаем ответ, (3) отображаем ответ. Давайте пойдём дальше и представим наш запрос в качестве потока. Сначала это кажется излишеством, но мы должны с чего-то начать, правильно?<br>При запуске мы должны сделать только один запрос, и если мы смоделируем это в виде потока данных, это будет поток только с одним значением. Позже у нас будет будет происходить много запросов, но для начала только один.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--a------|-&gt;</div><div class="line"></div><div class="line">Где a - это строка &apos;https://api.github.com/users&apos;</div></pre></td></tr></table></figure></p>
<p>Это поток URL адресов которые мы хотим запросить. При любом запросе происходит событие которое говорит нам две вещи: когда и что. “Когда” запрос должен быть выполнен – это когда событие передаст данные. И “Что” должно быть запрошено – это строка содержащая URL переданная в качестве значения.<br>Создать такой поток с единственным значением – это очень просто в Rx*. В официальной терминологии поток – это “наблюдаемая сущность” [Observable], по факту это то, что должно наблюдаться, но я нахожу это не совсем разумным именем и называю его просто потоком.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = Rx.Observable.just(<span class="string">'https://api.github.com/users'</span>);</div></pre></td></tr></table></figure></p>
<p>Но сейчас это просто поток строк, не выполняющий других операций, мы должны сделать чтобы что-то происходило когда значение будет передано. Это делается <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted" target="_blank" rel="external">подпиской</a> на поток.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">requestStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// execute the request</span></div><div class="line">  jQuery.getJSON(requestUrl, <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Заметьте, что мы используем обратный вызов jQuery Ajax (<a href="http://devdocs.io/jquery/jquery.getjson" target="_blank" rel="external">с которым вы, предполагаемо, уже знакомы</a>) чтобы обработать асинхронную операцию запроса. Но погодите, Rx предназначен для работы с асинхронными потоками данных. Может ли ответ для этого запроса быть потоком содержащим данные которые мы ожидаем? Ну что же, на концептуальном уровне это выглядит именно так, давайте попробуем.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">requestStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// Выполнение запроса</span></div><div class="line">  <span class="keyword">var</span> responseStream = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</div><div class="line">    jQuery.getJSON(requestUrl)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; observer.onNext(response); &#125;)</div><div class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, status, error</span>) </span>&#123; observer.onError(error); &#125;)</div><div class="line">    .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; observer.onCompleted(); &#125;);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="comment">// Делаем что-то с ответом</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Что именно делает <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe" target="_blank" rel="external"><code>Rx.Observable.create()</code></a> – это создаёт ваш кастомизированный поток с явным информированием каждого наблюдателя (другими словами “подписчика” [subscriber]) о событиях с данными (<code>onNext()</code>) или ошибке (<code>onError()</code>). То, что мы сделали – это просто обернули jQuery Ajax Promise. <strong>Но, значит ли это, что Промисы это и есть Observable?</strong><br>Да.<br>Observable – это Promise++. В Rx вы можете легко преобразовать промис в Observable <code>var stream = Rx.Observable.fromPromise(promise)</code>, давайте используем это. Единственная разница в том, что Observables не совместимы с <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="external">Promises/A+</a>, но концептуально они не расходятся. Промисы – это просто Observable с однократно передаваемым значением. Rx поток выходит за пределы возможностей промисов позволяя возвращать значения многократно.<br>Это довольно хорошо, и показывает что Observable по меньшей мере настолько же мощный инструмент как и промисы. Если вы доверяете шумихе вокруг промисов, давайте посмотрим на что ещё способны Rx Observables.<br>Вернёмся к нашему примеру. Если вы успели заметить, у нас есть один вызов <code>subscribe()</code>  внутри другого, что очень похоже на те же мучения с вложенными обратными вызовами. Так же создание <code>responseStream</code> зависит от <code>requestStream</code>. Как вы слышали прежде, в Rx есть простой механизм для трансформации и создания новых потоков вне других, и мы должны использовать это.<br>Одна из базовых функций которую вам следует узнать сейчас – это <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg" target="_blank" rel="external"><code>map(f)</code></a>, которая берёт каждое значение потока <code>A</code>, применяет <code>f()</code> на нём, и передаёт полученное значение в поток <code>B</code>. Если мы применим это к нашим потокам запроса и ответа, мы можем спроецировать URL адреса запроса в промисы ответа (Замаскированные под поток).<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> responseMetastream = requestStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>Тогда мы создадим нечто, что называется “метапоток”: поток потоков. Без паники. Метапоток – это поток в котором каждое полученное значение – это другой поток. Вы можете думать об этом как об указателях: каждое полученное значение – это указатель на другой поток. В нашем примере, каждый запрашиваемый URL спроецирован на указатель промис-потока содержащего соответствующий ответ.<br><img src="/introduction_to_reactive_programming_you_ve_been_missing/response_metastream.png" alt="Метапоток ответа"><br>Метапоток для ответов выглядит сбивающим с толку, и непохоже будто он нам помогает в чём-то. Мы просто хотим поток ответов, где каждое полученное значение – это JSON объект, а не промис JSON объекта. Тут мы встречаемся с <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector" target="_blank" rel="external">Flatmap</a> – версия <code>map()</code> которая “сплющивает” метапоток, передавая в родительский поток всё что будет получено из дочернего. Flatmap – это не фикс, и метапоток – это не баг, это в действительности инструменты предназначенные для работы с асинхронными ответами в Rx.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> responseStream = requestStream</div><div class="line">  .flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="/introduction_to_reactive_programming_you_ve_been_missing/response_stream.png" alt="Поток ответа"><br>Прекрасно. И так как поток ответа определён и соответствует связанному потоку запроса, если в потоке запроса произойдёт ещё одно событие, мы получим соответствующее событие ответа произошедшее в потоке ответа, как ожидается:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">requestStream:  --a-----b--c------------|-&gt;</div><div class="line">responseStream: -----A--------B-----C---|-&gt;</div><div class="line"></div><div class="line">(нижним регистром обозначены запросы, верхним - ответы)</div></pre></td></tr></table></figure></p>
<p>Сейчас в результате у нас есть поток ответа и мы можем отобразить полученные данные:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="comment">// отображаем `response` в DOM как вам угодно</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Объединив весь рассмотренный код мы получаем:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = Rx.Observable.just(<span class="string">'https://api.github.com/users'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> responseStream = requestStream</div><div class="line">  .flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="comment">// отображаем `response` в DOM как вам угодно</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Кнопка-обновления"><a href="#Кнопка-обновления" class="headerlink" title="Кнопка обновления"></a>Кнопка обновления</h2><p>Я пока не упоминал что JSON ответа – это список из 100 пользователей. API позволяет только определять сдвиг страницы, но не её размер, и при этом мы используем всего 3 объекта и расточительно оставляем без использования 97. Мы можем проигнорировать проблему на данный момент, но в дальнейшем мы увидим как кешировать результат ответа API.<br>Каждый раз когда кнопка обновления нажимается, поток запроса должен передать новый URL, и тогда мы можем получить новый ответ. Нам необходимы две вещи: поток событий кликов на кнопке обновления (мантра: всё должно быть потоком), и нам нужно изменить поток запроса чтобы он зависел от клика на кнопку обновления. Gladly и RxJS поставляются с инструментами для создания Observables из нативного события пользовательского интерфейса браузера.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> refreshButton = <span class="built_in">document</span>.querySelector(<span class="string">'.refresh'</span>);</div><div class="line"><span class="keyword">var</span> refreshClickStream = Rx.Observable.fromEvent(refreshButton, <span class="string">'click'</span>);</div></pre></td></tr></table></figure></p>
<p>После события клика на кнопке обновления она не предоставляет сама по себе какой-либо API URL, нам нужно спроецировать каждый клик на актуальный URL. Сейчас мы изменим поток запроса чтобы поток клика на кнопку обновления проецировался на запрос к API каждый раз со случайным значением параметра сдвига.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>Потому что я туповатый и у меня нет автоматизированных тестов, я просто сломал часть уже реализованного функционала. Запрос больше не происходит после окончания загрузки страницы, он происходит только по нажатию на кнопку обновления. Но мне нужны оба поведения: запрос по нажатию на кнопку обновления и после открытия страницы.<br>Мы знаем как создать отдельный поток для каждого из этих случаев:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line"><span class="keyword">var</span> startupRequestStream = Rx.Observable.just(<span class="string">'https://api.github.com/users'</span>);</div></pre></td></tr></table></figure></p>
<p>Но как мы можем сделать их слияние в один? Чтожь, здесь нам пригодится <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other" target="_blank" rel="external"><code>merge()</code></a>. Разъясним на языке диаграмм что это делает эта функция:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">поток A: ---a--------e-----o-----&gt;</div><div class="line">поток B: -----B---C-----D--------&gt;</div><div class="line">         vvvvvvvvv merge vvvvvvvvv</div><div class="line">         ---a-B---C--e--D--o-----&gt;</div></pre></td></tr></table></figure>
<p>Теперь это должно быть достаточно просто:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line"><span class="keyword">var</span> startupRequestStream = Rx.Observable.just(<span class="string">'https://api.github.com/users'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> requestStream = Rx.Observable.merge(</div><div class="line">  requestOnRefreshStream, startupRequestStream</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>Это альтернативный и более чистый путь без промежуточных потоков.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;)</div><div class="line">  .merge(Rx.Observable.just(<span class="string">'https://api.github.com/users'</span>));</div></pre></td></tr></table></figure></p>
<p>Ещё короче, даже более читаемо.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;)</div><div class="line">  .startWith(<span class="string">'https://api.github.com/users'</span>);</div></pre></td></tr></table></figure>
<p>Функция <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypestartwithscheduler-args" target="_blank" rel="external"><code>startWith</code></a> делает именно то, что вы думаете о том, что она делает. Не имеет значения как выглядит ваш вводный поток, выходящий поток с <code>startWith(x)</code> сначала получит <code>x</code>. Но у нас есть <a href="https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself" target="_blank" rel="external">повторяющийся код</a> – строка запроса к API. Один способ исправить это – перемещение <code>startWith</code> ближе к <code>refreshClickStream</code>, по существу эмулируя клик на кнопке обновления при старте.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">'startup click'</span>)</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>Прекраcно. Если мы вернёмся к точке где я “сломал автоматизированные тесты”, вы можете увидеть только одно отличие с последним подходом в котором я добавил <code>startWith</code>.</p>
<h2 id="Моделирование-трёх-предложений-с-помощью-потоков"><a href="#Моделирование-трёх-предложений-с-помощью-потоков" class="headerlink" title="Моделирование трёх предложений с помощью потоков"></a>Моделирование трёх предложений с помощью потоков</h2><p>До этого момента мы только соприкосались с элементом графического интерфейса предложений на этапе отображения данных который происходит в методе <code>subscribe()</code> потока responseStream. Сейчас у нас есть проблема с кнопкой обновления – как только вы кликнете “обновить”, текущие 3 предложения не очищаются. Новые предложения появляются только после того как мы получим ответ, но чтобы графический интерфейс реагировал ожидаемо, нам нужно очистить текущие предложения как только произойдёт клик на кнопке обновления.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">refreshClickStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// очистить 3 DOM-элемента предложений</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Не так быстро. Это плохой вариант, потому что у нас теперь <strong>два</strong> подписчика которые затрагивают DOM-элемент предложений (ещё один – это <code>responseStream.subscribe()</code>), и это не похоже на соблюдение паттерна <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" target="_blank" rel="external">Разделение ответственности</a>. Помните реактивную мантру?<br><img src="/introduction_to_reactive_programming_you_ve_been_missing/mantra.jpg" alt="Мантра"><br>Давайте смоделируем предложения как поток, в котором каждый следующий элемент – это JSON объект содержащий данные предложения. Мы сделаем это отдельно для каждого из трёх предложений. Так может выглядеть поток предложение№1:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</div><div class="line">    <span class="comment">// получаем одного случайного пользователя из списка</span></div><div class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>Другие, <code>suggestion2Stream</code> и <code>suggestion3Stream</code> могут быть просто скопированы из <code>suggestion1Stream</code>. Это чревато появлением повторяющегося кода, но это сохранит наш пример простым в рамках этого руководства, в добавок я думаю – это хоршее упражнение, подумать как избежать повторения в этом случае.<br>Вместо того, чтобы отображение происходило в <code>subscribe()</code> потока <code>responseStream</code>, мы сделаем следующее:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</div><div class="line">  <span class="comment">// Отобразим 1-е предложение в DOM</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Вернёмся к “при обновлении очищаем предложения”, мы можем просто спроецировать клик на кнопке обновлений на <code>null</code> значение данных предложения, и включить это в <code>suggestion1Stream</code>, как:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</div><div class="line">    <span class="comment">// Получаем одного случайного пользователя из списка</span></div><div class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">  &#125;)</div><div class="line">  .merge(</div><div class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</div><div class="line">  );</div></pre></td></tr></table></figure></p>
<p>При отображении мы интерпретируем <code>null</code> как “нет данных”, и следовательно скрываем соответствующие элементы графического интерфейса.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="comment">// Скрываем DOM-элемент первого предложения</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Показываем DOM-элемент первого предложения</span></div><div class="line">    <span class="comment">// и отображаем данные</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Общая картина:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">refreshClickStream: ----------o--------o----&gt;</div><div class="line">     requestStream: -r--------r--------r----&gt;</div><div class="line">    responseStream: ----R---------R------R--&gt;   </div><div class="line"> suggestion1Stream: ----s-----N---s----N-s--&gt;</div><div class="line"> suggestion2Stream: ----q-----N---q----N-q--&gt;</div><div class="line"> suggestion3Stream: ----t-----N---t----N-t--&gt;</div></pre></td></tr></table></figure></p>
<p>Где вместо <code>N</code> подставляется <code>null</code>.<br>Как бонус мы можем так же отобразить пустые предложения на старте. Это сделано добавлением startWith(null) в поток предложений:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</div><div class="line">    <span class="comment">// получаем одного случайного пользователя из списка</span></div><div class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">  &#125;)</div><div class="line">  .merge(</div><div class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</div><div class="line">  )</div><div class="line">  .startWith(<span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>В результате:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">refreshClickStream: ----------o---------o----&gt;</div><div class="line">     requestStream: -r--------r---------r----&gt;</div><div class="line">    responseStream: ----R----------R------R--&gt;   </div><div class="line"> suggestion1Stream: -N--s-----N----s----N-s--&gt;</div><div class="line"> suggestion2Stream: -N--q-----N----q----N-q--&gt;</div><div class="line"> suggestion3Stream: -N--t-----N----t----N-t--&gt;</div></pre></td></tr></table></figure>
<h2 id="Закрываем-предложения-и-используем-кеширование-ответа"><a href="#Закрываем-предложения-и-используем-кеширование-ответа" class="headerlink" title="Закрываем предложения и используем кеширование ответа"></a>Закрываем предложения и используем кеширование ответа</h2><p>Осталась одна функция которую осталось реализовать. Каждое предложение имеет свою кнопку ‘x’ чтобы закрыть его и загрузить другое на его место. На первый взгляд вы можете сказать, что достаточно сделать новый запрос когда какая-либо из кнопок будет нажата:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> close1Button = <span class="built_in">document</span>.querySelector(<span class="string">'.close1'</span>);</div><div class="line"><span class="keyword">var</span> close1ClickStream = Rx.Observable.fromEvent(close1Button, <span class="string">'click'</span>);</div><div class="line"><span class="comment">// то же самое для close2Button и close3Button</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">'startup click'</span>)</div><div class="line">  .merge(close1ClickStream) <span class="comment">// мы добавили это</span></div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>Это не работает. Это закроет и перезагрузит все предложения, вместо того на котором мы кликнули. Есть несколько различных путей исправить это, и чтобы это оставалось интересным, мы решим это повторным использованием предыдущего запроса. Размер ответа API – 100 пользователей в то время как мы использовали только 3 из них, и нам доступно ещё много акутальных данных. Нет необходимости запрашивать новые.<br>Опять давайте подумаем в потоках. Когда происходит событие клика ‘close1’, мы хотим использовать последний полученный ответ от <code>responseStream</code> получив одного случайного пользователя из списка ответа. По существу:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    requestStream: --r---------------&gt;</div><div class="line">   responseStream: ------R-----------&gt;</div><div class="line">close1ClickStream: ------------c-----&gt;</div><div class="line">suggestion1Stream: ------s-----s-----&gt;</div></pre></td></tr></table></figure></p>
<p>В Rx* есть функция комбинирования называемая <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecombinelatestargs-resultselector" target="_blank" rel="external"><code>combineLatest</code></a> которая похожа на то, что нам нужно. Она берёт два потока <code>A</code> и <code>B</code> на вход, и как только любой из потоков передаёт значение, <code>combineLatest</code> объединияет наиболее недавние полученные значения <code>a</code> и <code>b</code> из обоих потоков и выводит значение <code>x = f(x,y)</code>, где <code>f</code> – это определённая нами функция. Это лучше объяснить в виде диаграммы:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stream A: --a-----------e--------i--------&gt;</div><div class="line">stream B: -----b----c--------d-------q----&gt;</div><div class="line">          vvvvvvvv combineLatest(f) vvvvvvv</div><div class="line">          ----AB---AC--EC---ED--ID--IQ----&gt;</div><div class="line"></div><div class="line">где f - упомянутая функция</div></pre></td></tr></table></figure>
<p>Мы можем применить  <code>combineLatest()</code> на <code>close1ClickStream</code> и <code>responseStream</code>, тогда при любом нажатии кнопки закрытия 1, мы получим последнюю часть ответа и произведём новое значение в <code>suggestion1Stream</code>. С другой стороны, combineLatest() симметричен: при любом новом запросе полученном в <code>responseStream</code>, он будет скомбинирован с последним кликом ‘close 1’ чтобы создать новое предложение. Это интересный момент, потому что это позволяет нам упростить наш предыдущий код для <code>suggestion1Stream</code> таким образом:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream</div><div class="line">  .combineLatest(responseStream,             </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line">  .merge(</div><div class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</div><div class="line">  )</div><div class="line">  .startWith(<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>Одного кусочка всё ещё не хватает в пазле. combineLatest() использует последние значения из двух источников, но если один из этик источников не передаст что-нибудь, combineLatest() не может произвести событие с данными на выходоном потоке. Если вы посмотрите на ASCII диаграмму выше, вы увидите что вывода не будет когда первый поток передаёт значение <code>a</code>. Только когда следующий поток передаёт значение <code>b</code> он может создать выходное значение.<br>Есть различные пути, чтобы решить это, и мы будем использовать наиболее простой, который симулирует клик на кнопке ‘close 1’ при старте:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.startWith(<span class="string">'startup click'</span>) <span class="comment">// мы добавили это</span></div><div class="line">  .combineLatest(responseStream,             </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;l</div><div class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line">  .merge(</div><div class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</div><div class="line">  )</div><div class="line">  .startWith(<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>Мы сделали это. Завершённый код:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> refreshButton = <span class="built_in">document</span>.querySelector(<span class="string">'.refresh'</span>);</div><div class="line"><span class="keyword">var</span> refreshClickStream = Rx.Observable.fromEvent(refreshButton, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> closeButton1 = <span class="built_in">document</span>.querySelector(<span class="string">'.close1'</span>);</div><div class="line"><span class="keyword">var</span> close1ClickStream = Rx.Observable.fromEvent(closeButton1, <span class="string">'click'</span>);</div><div class="line"><span class="comment">// Такая же логика для close2 и close3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">'startup click'</span>)</div><div class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://api.github.com/users?since='</span> + randomOffset;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> responseStream = requestStream</div><div class="line">  .flatMap(<span class="function"><span class="keyword">function</span> (<span class="params">requestUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise($.ajax(&#123;url: requestUrl&#125;));</div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.startWith(<span class="string">'startup click'</span>)</div><div class="line">  .combineLatest(responseStream,             </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line">  .merge(</div><div class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</div><div class="line">  )</div><div class="line">  .startWith(<span class="literal">null</span>);</div><div class="line"><span class="comment">// Такая же логика для suggestion2Stream и suggestion3Stream</span></div><div class="line"></div><div class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="comment">// Скрываем DOM-элемент первого предложения</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Показываем DOM-элемент первого предложения</span></div><div class="line">    <span class="comment">// и отображаем данные</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Вы можете увидеть рабочий пример здесь <a href="http://jsfiddle.net/staltz/8jFJH/48/" target="_blank" rel="external">http://jsfiddle.net/staltz/8jFJH/48/</a><br>Кусок кода маленький но насыщенный: это функции управления множественными событиями с правильным разделением ответственности и даже кешированием ответа. Функциональный стиль делает код более декларативным чем императивным: мы не получаем последовательность инструкций для выполнения, мы просто говорим что должно происходить определяя отношения между потоками. Для примера, с Rx мы говорим что <code>suggestion1Stream</code> это ‘close 1’ поток скомбинированный с одним пользователем в последнем ответе, кроме того он должен быть равен <code>null</code> когда происходит обновление или пока происходит инициализация программы.<br>Заметьте также выразительное отсутствие условных операторов для управления выполнением, такие как  <code>if</code>, <code>for</code>, <code>while</code> и типичного управления выполнением с помощью коллбэков которое ожидается в JavaScript приложении. Вы можете даже избавиться от <code>if</code> и <code>else</code> в <code>subscribe()</code> используя выше <code>filter()</code> если угодно (Я оставил реализацию таких деталей для вас в виде упражнения). В Rx мы имеем поточные функции такие как <code>map</code>, <code>filter</code>, <code>scan</code>, <code>merge</code>, <code>combineLatest</code>, <code>startWith</code> и многие многие другие для управления логикой основанной на событиях. Этот набор функций даёт вам больше мощи в меньшем количестве кода.</p>
<h2 id="Как-быть-дальше"><a href="#Как-быть-дальше" class="headerlink" title="Как быть дальше"></a>Как быть дальше</h2><p>Если вы думаете, что <code>Rx*</code> будет вашей основной библиотекой для реактивного программирования, потратьте немного времени на ознакомление с <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md" target="_blank" rel="external">большим списком функций</a> для трансформации, комбинирования и создания Observables. Если вы хотите понять эти функции с помощью диаграмм потоков, посмотрите на RxJava – очень полезную документацию с <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables" target="_blank" rel="external">мраморными диаграммами</a> [Мраморные диаграммы - это попросту тип диаграмм описывающих преобразования данных, очень распространённый в сообществе реактивного программирования. Внушительная часть документации и рабочего процесса с Rx основываются на мраморных диаграммах.]. Когда вы где-то застреваете пытаясь что-то реализовать, нарисуйте диаграмму, подумайте что вы видите на ней и сравните с длинным списком функций. Такой порядок работы был эффективен на моём опыте.<br>Однажды начав серьёзно программировать на Rx, абсолютно необходимо понимать концепцию <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables" target="_blank" rel="external">когда нужно использовать холодные Observables, а когда горячие</a>. Если вы проигнориурете этот аспект, то он вернётся обратно и жёстко вас ударит. Оттачивайте ваше мастерство дальше изучая реальное функциональное программирование, и узнайте о таких проблемах, как сторонние эффекты которые влияют на Rx.<br>Но реактивное программирование – это не просто Rx. Это <a href="http://baconjs.github.io/" target="_blank" rel="external">Bacon.js</a> с которым можно работать более интуитивно без причуд с которыми временами вы сталкиваетесь в Rx. <a href="http://elm-lang.org/" target="_blank" rel="external">Язык Elm</a> живёт в своей отдельной категории: это Функциональный Реактивный <strong>язык</strong> Программирования[Functional Reactive Programming – FRP] который компилируется в JavaScript + HTML + CSS и оснащён <a href="http://debug.elm-lang.org/" target="_blank" rel="external">отладчиком с возможностью путешествия во времени</a>. Довольно круто.<br>Rx работает прекрасно для нагруженных событиями фронтенд-приложений. Но это технология не только для клиентской стороны, она работает отлично на бэкенде и близко к базам данных. По факту RxJava – это <a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html" target="_blank" rel="external">ключевой компонент для обеспечения параллельных вычислений в Netflix’s API</a>. Rx – это не фреймворк ограниченный определённым типом приложений или языков. В действительности это парадигма которую вы можете использовать когда программируете любое программное обеспечение основанное на событиях.</p>
<p>Перевод основан на <a target="_blank" href="https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87">RxJS: Don’t Unsubscribe</a> by <a target="_blank" href="https://medium.com/@benlesh">Ben Lesh</a>.</p>
</div><div class="tags"><a href="/tags/Переводы/">Переводы</a> <a href="/tags/Технологии/">Технологии</a> </div><div class="post__meta">06-09-2016</div></div><div class="post-nav"><a href="/dont_unsubscribe/" class="post-nav__pre">&lt; RxJS - Не используйте unsubscribe непосредственно</a><a href="/mutation-observer/" class="post-nav__next">Опции MutationObserver в правильном порядке &gt;</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">0000011111100000</div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-81003165-1', 'auto');
ga('send', 'pageview');</script><script>(function (d, w, c) {
  (w[c] = w[c] || []).push(function () {
    try {
      w.yaCounter39479315 = new Ya.Metrika({
        id: 39479315,
        clickmap: true,
        trackLinks: true,
        accurateTrackBounce: true,
        webvisor: true
      });
    } catch (e) {
    }
  });

  var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () {
            n.parentNode.insertBefore(s, n);
          };
  s.type = "text/javascript";
  s.async = true;
  s.src = "https://mc.yandex.ru/metrika/watch.js";

  if (w.opera == "[object Opera]") {
    d.addEventListener("DOMContentLoaded", f, false);
  } else {
    f();
  }
})(document, window, "yandex_metrika_callbacks");</script></div></body></html>