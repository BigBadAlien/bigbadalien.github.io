<!DOCTYPE html><html lang="ru"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RxJS - Не используйте unsubscribe непосредственно | Разработка всего</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=0.0.0"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans|PT+Sans+Narrow:400,700|PT+Sans+Caption"><link href='' rel='stylesheet' type='text/css'></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RxJS - Не используйте unsubscribe непосредственно</h1><a id="logo" href="/.">Разработка всего</a><p class="description"></p></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RxJS - Не используйте unsubscribe непосредственно</h1><div class="post-content"><p>Чтож, только не отказывайтесь от отписывания слишком сильно.</p>
<p>Я часто берусь помогать кому-нибудь с отладкой и вопросами по RxJS коду или выяснению как лучше структурировать приложение, которое состоит из достаточно многих асинхронных частей. Когда я делаю это, я в целом вижу одну и ту же вещь снова и снова - люди хранят тонны и тонны объектов подписывания [те, что возвращает метод <code>subscribe</code>]. Разработчики неизменно делают 3 HTTP запроса с помощью Observable и хранят 3 объекта подписки, которые они собираются вызвать когда произойдёт какое-то событие [чтобы уничтожить подписку].</p>
<p>Я могу предположить как это могло бы случиться. Люди привыкли использовать <code>addEventListener</code> N раз и после этого необходима некоторая уборка когда они должны вызывать <code>removeEventListener</code> так же N раз. Кажется естественным делать то же самое с объектами подписки, и по большей части вы правы. Но есть путь лучше. Хранить слишком много объектов подписки - это знак того, что вы управляете своими подписками императивно, и не используете силу Rx.</p>
<h2 id="Как-выглядит-императивное-управление-подписками"><a href="#Как-выглядит-императивное-управление-подписками" class="headerlink" title="Как выглядит императивное управление подписками"></a>Как выглядит императивное управление подписками</h2><p>Возьмём для примера этот воображаемый компонент (Я намеренно сдлелал его не-React, не-Angular а чем-то более общим)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGenericComponent</span> <span class="keyword">extends</span> <span class="title">SomeFrameworkComponent</span> </span>&#123;</div><div class="line"> updateData(data) &#123;</div><div class="line">  <span class="comment">// здесь обновляем компонент способом, который зависит от используемого фреймворка</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> onMount() &#123;</div><div class="line">  <span class="keyword">this</span>.dataSub = <span class="keyword">this</span>.getData()</div><div class="line">   .subscribe(data =&gt; <span class="keyword">this</span>.updateData(data));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> cancelBtn = <span class="keyword">this</span>.element.querySelector(‘.cancel-button’);</div><div class="line">  <span class="keyword">const</span> rangeSelector = <span class="keyword">this</span>.element.querySelector(‘.rangeSelector’);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.cancelSub = Observable.fromEvent(cancelBtn, ‘click’)</div><div class="line">   .subscribe(() =&gt; &#123;</div><div class="line">    <span class="keyword">this</span>.dataSub.unsubscribe();</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.rangeSub = Observable.fromEvent(rangeSelector, ‘change’)</div><div class="line">   .map(e =&gt; e.target.value)</div><div class="line">   .subscribe((value) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (+value &gt; <span class="number">500</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.dataSub.unsubscribe();</div><div class="line">    &#125;</div><div class="line">   &#125;);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> onUnmount() &#123;</div><div class="line">  <span class="keyword">this</span>.dataSub.unsubscribe();</div><div class="line">  <span class="keyword">this</span>.cancelSub.unsubscribe();</div><div class="line">  <span class="keyword">this</span>.rangeSub.unsubscribe();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>В примере выше вы можете увидеть явный вызов <code>unsubscribe</code> на трёх объектах подписок, которыми я управляю сам в методе <code>onUnmount()</code>. Так же я вызываю <code>this.dataSub.unsubscribe()</code> когда кто-то кликнет по кнопке отмены в строке #15, и ещё раз в строке #22 когда пользователь выставляет селектор выбора диапазона выше 500 - пороговое значение, которые я хочу, чтобы останавливало поток данных (Я точно не знаю зачем, это странный компонент для примера).</p>
<p>Безобразие здесь в том, что я императивно управляю отписыванием подписок в нескольких разных местах в этом довольно тривиальном примере.</p>
<p>Единственное реальное преимущество такого подхода была бы производительность. Так как вы использовали меньше абстракций чтобы реализовать код, он, вероятно, выполнится немного шустрее. Это врядли будет иметь заметный эффект в большинстве веб-прирложений, и я не думаю что это то, о чём стоит беспокоиться.</p>
<p>С другой стороны, вы можете всегда комбинировать подписки в одну единственную подписку с помощью создания родительской подписки и добавления к ней других дочерних. Но к концу дня, вы скорее всего будете делать всё ту же вещь, что и в начале, и вероятность запутаться очень велика. </p>
<h2 id="Компонуйте-управление-подписками-с-помощью-takeUntil"><a href="#Компонуйте-управление-подписками-с-помощью-takeUntil" class="headerlink" title="Компонуйте управление подписками с помощью takeUntil"></a>Компонуйте управление подписками с помощью takeUntil</h2><p>Сейчас давайте переделаем тот же простой пример, только с использованием RxJS оператора <code>takeUntil</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGenericComponent</span> <span class="keyword">extends</span> <span class="title">SomeFrameworkComponent</span> </span>&#123;</div><div class="line"> updateData(data) &#123;</div><div class="line">  <span class="comment">// здесь обновляем компонент способом, который зависит от используемого фреймворка</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> onMount() &#123;</div><div class="line">   <span class="keyword">const</span> data$ = <span class="keyword">this</span>.getData();</div><div class="line">   <span class="keyword">const</span> cancelBtn = <span class="keyword">this</span>.element.querySelector(‘.cancel-button’);</div><div class="line">   <span class="keyword">const</span> rangeSelector = <span class="keyword">this</span>.element.querySelector(‘.rangeSelector’);</div><div class="line">   <span class="keyword">const</span> cancel$ = Observable.fromEvent(cancelBtn, <span class="string">'click'</span>);</div><div class="line">   <span class="keyword">const</span> range$ = Observable.fromEvent(rangeSelector, <span class="string">'change'</span>).map(e =&gt; e.target.value);</div><div class="line">   </div><div class="line">   <span class="keyword">const</span> stop$ = Observable.merge(cancel$, range$.filter(x =&gt; x &gt; <span class="number">500</span>))</div><div class="line">   <span class="keyword">this</span>.subscription = data$.takeUntil(stop$).subscribe(data =&gt; <span class="keyword">this</span>.updateData(data));</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> onUnmount() &#123;</div><div class="line">  <span class="keyword">this</span>.subscription.unsubscribe();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Первое что можно заметить - кода стало меньше. Это только одно преимущество. Другое - мы получили композицию потока <code>stop$</code> событий которые заканчивают поток данных. Это значит, что кода я решу добавить другое условие для закрытия потока данных, например, скажем, по таймеру, я просто сделаю слияние нового наблюдаемого объекта в <code>stop$</code>. Ещё одно преимущество довольно очевидно - у меня есть только один объект подписки, которым я управляю императивно. С этим ничего не поделать, потому что в этом месте функциональное программирование встречается с объектно-ориентированным миром. JavaScript императивный язык в конце концов, и мы должны встретиться с этим в какой-то момент.</p>
<p>Другое преимущество этого подхода - это фактическое завершение наблюдаемого объекта. Это означает что происходит событие завершения которое может быть обработано в любое время когда вы захотите завершить ваш наблюдаемый объект. Если вы просто вызываете <code>unsubscribe</code> на возвращённом объекте подписки, нет никакой возможности получить уведомление о том, что отписка произошла. Однако, если вы используете <code>takeUntil</code> (или другоие операторы перечисленные ниже), вы будете уведомлены в обработчике завершения [аргумент <code>onCompleted</code> функции <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md" target="_blank" rel="external"><code>subscribe</code></a>] что наблюдаемый объект был остановлен. </p>
<p>Последнее преимущество - это то, что в действтительности вы связываете всё в одном месте одним вызовом <code>subscribe</code>. Это выгодно потому что становится намного-намного легче найти - где вы начали вашу подписку в коде. Помните, что наблюдаемые объекты не делают ничего пока вы не подпишитесь на них, и по-этому точка подписывания - очень важное место в коде.</p>
<p>Есть один недостаток с точки зрения семантики RxJS, но об этом едва стоит беспокоиться перед лицом перечисленных преимуществ. Недостаток в семантике заключается в том, что завершение наблюдаемого объекта - это знак, что производитель событий хочет сказать потребителю, что он выполнен, а отписка означает, что потребитель сообщаяет производителю, что он больше не нуждается в данных.</p>
<p>Так же в худшую сторону будет очень небольшая разница в производительности между новым подходом и просто императивным вызовом <code>unsubscribe</code>.</p>
<h2 id="Другие-операторы"><a href="#Другие-операторы" class="headerlink" title="Другие операторы"></a>Другие операторы</h2><p>Есть много других путей, чтобы закончить поток более естественным для Rx пособом. Я рекомендую познакомиться по меньшеу мере со следующими операторами: </p>
<ul>
<li>take(n): производит N значений перед тем как остановить наблюдаемый объект.</li>
<li>takeWhile(predicate): проверяет производимое значение с помощью функции-предиката, если она возвращет <code>false</code>, поток будет завершён.</li>
<li>first(): производит первое значение и завершает поток.</li>
<li>first(predicate): проверяет каждое значение с помощью функции-предиката, если какое-то из них вернёт <code>true</code>, значение будет произведено и поток завершён.</li>
</ul>
<h2 id="Вывод-используйте-takeUntil-takeWhile-и-другие"><a href="#Вывод-используйте-takeUntil-takeWhile-и-другие" class="headerlink" title="Вывод: используйте takeUntil, takeWhile, и другие."></a>Вывод: используйте <code>takeUntil</code>, <code>takeWhile</code>, и другие.</h2><p>You should probably be using operators like <code>takeUntil</code> to manage your RxJS subscriptions. As a rule of thumb, if you see two or more subscriptions being managed in a single component, you should wonder if you could be composing those better.<br>Вам следовало бы так же использовать операторы вроде <code>takeUntil</code> для управления вашими подписками RxJS. Как правило большого пальца - если вы видите две или больше подписки которыми собираетесь управлять в одном компоненте, вам следует задаваться вопросом - возможно ли сделать их комбинирование лучше:</p>
<ul>
<li>более легко компонуемыми;</li>
<li>с событием завершения когда вы завершаете поток;</li>
<li>в целом с меньшим количество кода;</li>
<li>с меньшим явным управлением;</li>
<li>с меньшим количеством фактических точек подписки (из-за меньшего количества вызовов <code>subscribe</code>).</li>
</ul>
</div><div class="tags"><a href="/tags/Переводы/">Переводы</a> <a href="/tags/Технологии/">Технологии</a> </div><div class="post__meta">26-10-2016</div></div><div class="post-nav"><a href="/introduction_to_reactive_programming_you_ve_been_missing/" class="post-nav__next">Недостающее введение в Реактивное Программирование &gt;</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">0000011111100000</div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-81003165-1', 'auto');
ga('send', 'pageview');</script><script>(function (d, w, c) {
  (w[c] = w[c] || []).push(function () {
    try {
      w.yaCounter39479315 = new Ya.Metrika({
        id: 39479315,
        clickmap: true,
        trackLinks: true,
        accurateTrackBounce: true,
        webvisor: true
      });
    } catch (e) {
    }
  });

  var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () {
            n.parentNode.insertBefore(s, n);
          };
  s.type = "text/javascript";
  s.async = true;
  s.src = "https://mc.yandex.ru/metrika/watch.js";

  if (w.opera == "[object Opera]") {
    d.addEventListener("DOMContentLoaded", f, false);
  } else {
    f();
  }
})(document, window, "yandex_metrika_callbacks");</script></div></body></html>